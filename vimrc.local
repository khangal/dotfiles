set relativenumber
" set hlsearch
set background=dark
colorscheme solarized

set complete=.,w,b,u,t

":1 Mappings
nmap <Leader>ci :source ~/.vimrc.local<cr>
nmap <Leader>bi :source ~/.vimrc.local<cr>:PlugInstall<cr>
map <C-s> <esc>:w<CR>
imap <C-s> <esc>:w<CR>
map <Leader>vi :tabe ~/.vimrc.local<CR>
map <Leader>vb :tabe ~/.vimrc.bundles.local<CR>
map <Leader>da :tabe ~/.cheatsheet.markdown<CR>
map <Leader>q :tabe ~/.ideas.markdown<CR>
map <C-h> :nohl<cr>

" Fix Ubuntu 16.04 move cursor by word in CmdLine mode
cnoremap [1;5D <C-Left>
cnoremap [1;5C <C-Right>

" Emacs-like beginning and end of line.
imap <c-e> <c-o>$
imap <c-a> <c-o>^

imap <C-k> <CR><c-o>O
command! Q q " Bind :Q to :q

" Execute macro in q
map Q @q

map <Leader>p :set paste<CR><esc>"+p:set nopaste<cr>:retab<cr>
vnoremap <C-c> "+y

" endfold
":2 Stylus compile
augroup StylusCompile
  autocmd FileType stylus
    \ autocmd! StylusCompile BufWritePost <buffer> !stylus -u nib -u rupture --include-css -p "%" > "%:r"; sed -i -e '1i/* Generated by Stylus '`stylus --version`' */\' "%:r"
augroup END
" endfold
":1 Library configs

" Ultisnippets
let g:UltiSnipsExpandTrigger="<s-tab>"
let g:UltiSnipsJumpForwardTrigger="<s-tab>"

" Enable Emmet just for HTML/CSS/ERB
let g:user_emmet_install_global = 0
autocmd FileType html,css,javascript,eruby,eco,php,htmljinja,eelixir EmmetInstall

let g:user_emmet_expandabbr_key = '<C-l>'
let g:user_emmet_complete_tag = 1

let g:jsx_ext_required = 0
let g:syntastic_mode_map = { 'mode': 'active', 'active_filetypes': [],'passive_filetypes': ['python'] }
let g:syntastic_python_flake8_post_args = "--max-line-length=100 --inline-quotes '\"' *.py"

" endfold

autocmd FileType yaml setlocal foldmethod=indent
autocmd FileType yaml setlocal foldlevel=1
autocmd FileType html,htmljinja setlocal textwidth=140
autocmd FileType python setlocal textwidth=100


":2 Vim folding
function! g:VimFoldText()
  let l:line = getline(v:foldstart)
  let l:trimmed = substitute(l:line, '^\s*\(.\{-}\)\s*$', '\1', '')
  let l:leading_spaces = stridx(l:line, l:trimmed)
  let l:prefix = repeat(' ', l:leading_spaces)
  let l:size = strlen(l:trimmed)

  let l:trimmed = strpart(l:trimmed, 4, l:size - 4)
  return l:prefix . 'â–¸   ' . l:trimmed
endfunction

autocmd FileType vim setlocal foldmethod=marker foldmarker=\"\:,\"\ endfold foldtext=g:VimFoldText()

":1 Stylus, Sass folding
":2 | StylusFoldText
function! g:StylusFoldText()
  return getline(v:foldstart)
endfunction

":2 | StylusFoldExpr
function! g:StylusFoldExpr()
  let l:line = getline(v:lnum)

  if l:line =~# '^[^ ]' && getline(v:lnum + 1) =~# '^  '
    return '>1'
  endif

  if l:line =~# '^$' && getline(v:lnum + 1) =~# '^$'
    return '<1'
  endif

  if l:line =~# '^// endfold'
    return '<1'
  endif

  if l:line =~# '^  [^ ]' && getline(v:lnum + 1) =~# '^    '
    return '>2'
  endif

  if l:line =~# '^    ' && getline(v:lnum + 1) =~# '^$' && getline(v:lnum + 2) =~# '^[^ ]'
    return '<2'
  endif

  return '='
endfunction

autocmd FileType stylus setlocal foldmethod=expr foldexpr=g:StylusFoldExpr() foldtext=g:StylusFoldText()

":1 Python folding
let $PYTHONDONTWRITEBYTECODE = 1
let $PYTHONIOENCODING = 'utf-8'

":2 PythonFoldExpr
function! g:PythonFoldExpr()
  ":3 Variable reset
  if v:lnum == 1
    let s:fold = 0          " fold level
    let s:in_docstring = 0  " in docstring
  endif
  " endfold

  " if docstring started
  if s:in_docstring
    ":3 in dostring
    " Docstring close
    if getline(v:lnum) =~? '.*"""$'
      let s:in_docstring = 0
    endif

    return '='
    " endfold
  else
    ":3 == | docstring start
    if getline(v:lnum) =~? '"""'
    if getline(v:lnum) !~? '""".*"""$'
      let s:in_docstring = 1
      return '='
    endif
    endif
    " endfold

    ":3 +1 | import lines start
    if getline(v:lnum - 1) !~? '^\(from\|import\) '
    if getline(v:lnum + 0) =~? '^\(from\|import\) '
      return '>1'
    endif
    endif

    ":3 =1 | import lines middle
    if getline(v:lnum - 1) =~? '^\(from\|import\) '
    if getline(v:lnum + 0) =~? '^\(from\|import\) '
      return '='
    endif
    endif

    ":3 -1 | import lines close
    if getline(v:lnum - 1) =~? '^\(from\|import\) '
    if getline(v:lnum - 0) !~? '^\(from\|import\) '
      return '<1'
    endif
    endif
    " endfold

    ":3 +1 | decorator start
    if getline(v:lnum) =~? '^@'
      let s:fold = 1
      return '>1'
    endif

    ":3 =1 | decorator's next line
    if getline(v:lnum - 1) =~? '^@'
      return '='
    endif

    ":3 +1 | class|def|if|for|while start
    if getline(v:lnum) =~? '^\(class\|def\|if\|for\|while\) '
      let s:fold = 1
      return '>1'
    endif

    ":3 +1 | try|except|finally start
    if getline(v:lnum) =~? '^\(try:\|except:\|except \|finally:\)'
      let s:fold = 1
      return '>1'
    endif

    ":3 +1 | # title
    if getline(v:lnum) =~# '^# [A-Z0-9-]'
      let s:fold = 1
      return '>1'
    endif

    if s:fold == 0 && getline(v:lnum) =~# '^\s\{4\}# [A-Z0-9-]'
      let s:fold = 1
      return '>1'
    endif

    ":3 -1 | # endfold
    if getline(v:lnum) =~# '^# endfold'
      let s:fold = 0
      return '<1'
    endif

    ":3 -1 | this, next is empty, next-next is not `class |def |@`
    if getline(v:lnum + 0) !~? '\v\S'
    if getline(v:lnum + 1) !~? '\v\S'
    if getline(v:lnum + 2) !~? '^\(class \|def \|@\)'
      let s:fold = 0
      return '<1'
    endif
    endif
    endif

    ":3 =1 | 2 empty line allowed in zero indent
    if getline(v:lnum - 1) =~? '^\S'
    if getline(v:lnum + 0) !~? '\v\S'
    if getline(v:lnum + 1) !~? '\v\S'
      return '<1'
    endif
    endif
    endif
    " endfold

    ":3 +2 | decorator start
    if getline(v:lnum) =~? '^\s\{4\}@'
      let s:fold = 2
      return '>2'
    endif

    ":3 =2 | decorator's next line
    if getline(v:lnum - 1) =~? '^\s\{4\}@'
      return '='
    endif

    ":3 +2 | class|def start
    if getline(v:lnum) =~? '^\s\{4\}\(class\|def\) '
      let s:fold = 2
      return '>2'
    endif

    ":3 +2 | step("-
    if getline(v:lnum) =~? '^\s\{4\}step(\"'
      let s:fold = 2
      return '>2'
    endif

    ":3 +2 | # title
    if getline(v:lnum) =~# '^\s\{4\}# [A-Z0-9-]'
      let s:fold = 2
      return '>2'
    endif

    ":3 -2 | # endfold
    if getline(v:lnum) =~# '^\s\{4\}# endfold'
      let s:fold = 1
      return '<2'
    endif

    ":3 -2 | next, next-next is empty
    if getline(v:lnum + 1) !~? '\v\S'
    if getline(v:lnum + 2) !~? '\v\S'
      let s:fold = 1
      return '<2'
    endif
    endif
    " endfold

    ":3 +3 | # title
    if getline(v:lnum) =~# '^\s\{8,\}# [A-Z0-9-]'
      if s:fold == 1
        return '>2'
      endif
      if s:fold == 2
        return '>3'
      endif
    endif

    ":3 -3 | # endfold
    if getline(v:lnum) =~# '^\s\{8,\}# endfold'
      if s:fold == 1
        return '<2'
      endif
      if s:fold == 2
        return '<3'
      endif
    endif
    " endfold

    return '='
  endif
endfunction

":2 PythonFoldText
function! g:PythonFoldText()
  let l:line = getline(v:foldstart)
  let l:trimmed = substitute(l:line, '^\s*\(.\{-}\)\s*$', '\1', '')
  let l:leading_spaces = stridx(l:line, l:trimmed)
  let l:prefix = repeat(' ', l:leading_spaces)
  let l:nextline = getline(v:foldstart + 1)
  let l:nextline_trimmed = substitute(l:nextline, '^\s*\(.\{-}\)\s*$', '\1', '')

  if l:trimmed =~# '^@classmethod'
    let l:custom_text = '@classmethod ' . substitute(strpart(l:nextline_trimmed, 4), ':', '', '') . ''

  elseif l:trimmed =~# '^\(from \|import \)'
    let l:custom_text = 'import'

  elseif l:trimmed =~# '^step'
    let l:custom_text = l:trimmed
    let l:custom_text = substitute(l:custom_text, '(', '', '')
    let l:custom_text = substitute(l:custom_text, '"', '', '')
    let l:custom_text = substitute(l:custom_text, ')', '', '')
    let l:custom_text = substitute(l:custom_text, '\\n', '', '')

    let l:custom_text = 'â–¸     ' . l:custom_text[4:]

  elseif l:trimmed =~# '^@task'
    let l:custom_text = '@task ' . strpart(l:nextline_trimmed, 4, strlen(l:nextline_trimmed) - 5)

  elseif l:trimmed =~# '^@cron'
    let l:custom_text = '@cron ' . strpart(l:nextline_trimmed, 4, strlen(l:nextline_trimmed) - 5)

  elseif l:trimmed =~# '^@property'
    let l:custom_text = '@property ' . strpart(split(l:nextline_trimmed, '(')[0], 4)

  elseif l:trimmed =~# '\.setter$'
    let l:after_part = substitute(l:nextline_trimmed, ':', '', '')
    let l:custom_text = 'def @' . strpart(substitute(l:after_part, '(', '.setter(', ''), 4)

  elseif l:trimmed =~# '@'
    let l:fillcharcount = 80 - len(l:prefix) - len(substitute(l:trimmed, '.', '-', 'g'))
    let l:custom_text = '@' . strpart(l:trimmed, 1) . repeat(' ', l:fillcharcount) . substitute(l:nextline_trimmed, ':', '', '')

  elseif l:trimmed =~# '^# [A-Z0-9-]'
    let l:custom_text = 'â–¸ ' . strpart(l:trimmed, 2)

  elseif l:trimmed =~# '^def test_'
    let l:custom_text = l:trimmed
    let l:custom_text = substitute(l:custom_text, '(', '', '')
    let l:custom_text = substitute(l:custom_text, ')', '', '')
    let l:custom_text = 'def test ' . substitute(strpart(l:custom_text, 9), ':', ' ', '')

  elseif l:trimmed =~# '^def '
    let l:custom_text = 'def ' . substitute(strpart(l:trimmed, 4), ':', ' ', '')

  elseif l:trimmed =~# '^class '
    let l:custom_text = 'class ' . substitute(strpart(l:trimmed, 6), ':', '', '')

  elseif l:trimmed =~# '^if '
    let l:custom_text = 'if ' . substitute(strpart(l:trimmed, 3), ':', '', '')

  elseif l:trimmed =~# '^for '
    let l:custom_text = 'for ' . substitute(strpart(l:trimmed, 4), ':', '', '')

  elseif l:trimmed =~# '^while '
    let l:custom_text = 'while ' . substitute(strpart(l:trimmed, 6), ':', ' ', '')

  elseif l:trimmed =~# '^try:'
    let l:custom_text = 'try' . substitute(strpart(l:trimmed, 3), ':', ' ', '')

  elseif l:trimmed =~# '^except:'
    let l:custom_text = 'except' . substitute(strpart(l:trimmed, 7), ':', ' ', '')

  elseif l:trimmed =~# '^except '
    let l:custom_text = 'except ' . substitute(strpart(l:trimmed, 7), ':', ' ', '')

  elseif l:trimmed =~# '^finally:'
    let l:custom_text = 'finally' . substitute(strpart(l:trimmed, 7), ':', ' ', '')

  else
    return foldtext()
  endif

  return l:prefix . l:custom_text
endfunction
" endfold

autocmd FileType python setlocal foldmethod=expr foldexpr=g:PythonFoldExpr() foldtext=g:PythonFoldText()

":1 HTML folding
":2 HTMLFoldExpr
function! g:HTMLFoldExpr()
  let l:trimmed = substitute(getline(v:lnum), '^\s*\(.\{-}\)\s*$', '\1', '')

  ":3 +1 | `{% macro `
  if getline(v:lnum) =~? '^{% macro '
    return '>1'
  endif

  if getline(v:lnum) =~? '^{%- macro '
    return '>1'
  endif

  ":3 +1 | `#: `
  if l:trimmed =~? '^#: '
    return '>1'
  endif

  ":3 -1 | `#:endfold`
  if l:trimmed =~? '^#:endfold$'
    return '<1'
  endif
  " endfold

  ":3 +2 | `#:2`
  if l:trimmed =~? '^#:2'
    return '>2'
  endif

  ":3 -2 | `#:endfold2`
  if l:trimmed =~? '^#:endfold2'
    return '<2'
  endif
  " endfold

  return '='
endfunction

":2 HTMLFoldText
function! g:HTMLFoldText()
  let l:line = getline(v:foldstart)
  let l:trimmed = substitute(l:line, '^\s*\(.\{-}\)\s*$', '\1', '')
  let l:leading_spaces = stridx(l:line, l:trimmed)
  let l:prefix = repeat(' ', l:leading_spaces)
  let l:size = strlen(l:trimmed)

  if l:trimmed[:3] ==# '#: <'
    return l:prefix . '' . l:trimmed[3:]
  elseif l:trimmed[:4] ==# '#:2 <'
    return l:prefix . '' . l:trimmed[4:]
  elseif l:trimmed[:1] ==# '{%'
    return l:prefix . l:trimmed
  elseif l:trimmed[:1] ==# '{#'
    let l:trimmed = strpart(l:trimmed, 5, l:size - 5)
    let l:trimmed = substitute(l:trimmed, '{', '', 'g')
    let l:trimmed = substitute(l:trimmed, '#', '', 'g')
    let l:trimmed = substitute(l:trimmed, '}', '', 'g')
    return l:prefix . l:trimmed
  elseif l:trimmed[0] ==# '#'
    let l:trimmed = strpart(l:trimmed, 3, l:size - 3)
    let l:trimmed = substitute(l:trimmed, '{', '', 'g')
    let l:trimmed = substitute(l:trimmed, '#', '', 'g')
    let l:trimmed = substitute(l:trimmed, '}', '', 'g')
    return l:prefix . 'â–¸  ' . l:trimmed
  else
    return l:prefix . l:trimmed
  endif
endfunction
" endfold

autocmd FileType htmljinja setlocal foldmethod=expr foldexpr=g:HTMLFoldExpr() foldtext=g:HTMLFoldText()

":1 Javascript folding
function! g:JavascriptFoldText()
  let l:line = getline(v:foldstart)
  let l:trimmed = substitute(l:line, '^\s*\(.\{-}\)\s*$', '\1', '')
  let l:leading_spaces = stridx(l:line, l:trimmed)
  let l:prefix = repeat(' ', l:leading_spaces)
  let l:size = strlen(l:trimmed)

  let l:trimmed = strpart(l:trimmed, 4, l:size - 4)
  return l:prefix . 'â–¸   ' . l:trimmed
endfunction
autocmd FileType javascript setlocal foldmethod=marker foldmarker=\/\/\:,\/\/\ endfold foldtext=g:JavascriptFoldText()
autocmd FileType javascript setlocal autoindent
